
--[[
  Project: Title — Unified Filename Parser (v5)
  Handles Author, Title, Series, Index from filename using user's schema:

    Nom, Prénom - [Série [#|n°]Index - ]Titre.ext
    Variants:
      Nom, Prénom - Titre
      Nom, Prénom - Série - Titre
      Nom, Prénom - Série n°3 - Titre
      Nom, Prénom - Série #3 - Titre
      Nom, Prénom, Titre (fallback comma form)

  Notes:
    - Never split on internal hyphens (Jean-Philippe, demi-lune, etc.).
    - Unicode normalization of spaces, dashes, quotes, ZWSP, BOM.
    - If parsing fails, metadata is left untouched.
    - Series ignored if middle is only marker words (tome, vol, n°, etc.).
--]]

local userpatch = require("userpatch")

local function trim(s) return (s and s:gsub("^%s+",""):gsub("%s+$","")) end

-- Normalize Unicode variants to ASCII equivalents
local function normalize(s)
  if not s or s == "" then return s end
  -- remove zero-width, soft hyphen, BOM
  s = s
    :gsub("\226\128[\139-\141]", "") -- ZWSP/ZWNJ/ZWJ
    :gsub("\239\187\191", "") -- BOM
    :gsub("\194\173", "") -- soft hyphen
  -- normalize spaces
  s = s
    :gsub("\194\160", " ")
    :gsub("\226\128[\136-\143]", " ") -- thin, narrow, en/em space
  -- normalize dashes
  s = s
    :gsub("\226\128[\144-\148]", "-")
    :gsub("\226\136\146", "-")
  -- normalize apostrophes
  s = s:gsub("[\226\128\152\226\128\153]", "'")
  -- collapse multiple spaces
  s = s:gsub(" +", " ")
  -- keep only " - " for separators
  s = s:gsub(" +%- +", " - ")
  return trim(s)
end

local function split_on_sds(name)
  local parts, rest = {}, name
  while true do
    local i, j = rest:find(" %-% ")
    if not i then break end
    table.insert(parts, trim(rest:sub(1, i-1)))
    rest = rest:sub(j+1)
  end
  table.insert(parts, trim(rest))
  return parts
end

local function ci_cleanup_markers(s)
  local cleaned = s:gsub("[%s#]*%d+%s*$", "")
  cleaned = cleaned
    :gsub("[%s%p]*[Tt][Oo][Mm][Ee]%s*$", "")
    :gsub("[%s%p]*[Vv][Oo][Ll]%.?%s*$", "")
    :gsub("[%s%p]*[Ll][Ii][Vv][Rr][Ee]%s*$", "")
    :gsub("[%s%p]*[Nn][%s%.°Ooº]*%s*$", "")
  cleaned = cleaned:gsub("%s+$", "")
  return cleaned
end

local function parse_filename(basename)
  local name = normalize(basename or ""):gsub("%.%w+$","")
  local parts = split_on_sds(name)

  -- fallback: comma form if no " - " found
  if #parts == 1 and name:find(",") then
    local a, t = name:match("^(.-),%s*(.-)$")
    if a and t then
      return trim(a), nil, trim(t)
    end
  end

  if #parts < 2 then return nil, nil, nil, nil end

  local author = parts[1]
  local title = parts[#parts]
  local middle = (#parts >= 3) and table.concat(parts, " - ", 2, #parts-1) or nil

  local series, idx = nil, nil
  if middle and middle ~= "" then
    local raw = middle
    local n = tonumber(raw:match("(%d+)%s*$"))
    if n then
      local sname = ci_cleanup_markers(raw)
      sname = trim(sname or "")
      if sname ~= "" and not sname:lower():match("^[%s%p]*(tome|vol%.?|livre|n[%.°oº]?)%s*$") then
        series, idx = sname, n
      end
    else
      if not raw:lower():match("^[%s%p]*(tome|vol%.?|livre|n[%.°oº]?)%s*$") then
        series = trim(raw)
      end
    end
  end

  return trim(author), series, trim(title), idx
end

local function leaf(path)
  return tostring(path or ""):gsub("[/\\]+$",""):match("([^/\\]+)$") or tostring(path or "")
end

local function base_noext(filename)
  return tostring(filename or ""):gsub("%.%w+$","")
end

local function patchCoverBrowser(_plugin)
  local listmenu = require("listmenu")
  local ListMenuItem = userpatch.getUpValue(listmenu._updateItemsBuildUI, "ListMenuItem")
  if not ListMenuItem then return end

  local BookInfoManager = require("bookinfomanager")
  local util = require("util")
  local filemanagerutil = require("apps/filemanager/filemanagerutil")
  local orig_ListMenuItem_update = ListMenuItem.update

  ListMenuItem.update = function(self)
    if self.do_filename_only or not self or type(self.filepath) ~= "string" or self.filepath == "" or self.is_directory then
      return orig_ListMenuItem_update(self)
    end

    local wanted_leaf = leaf(self.filepath)
    local wanted_base = base_noext(wanted_leaf)

    local orig_get = BookInfoManager.getBookInfo
    local restored = false
    local function restore() if not restored then BookInfoManager.getBookInfo = orig_get; restored = true end end

    BookInfoManager.getBookInfo = function(bim, path, want_cover)
      local req_path = path
      if type(req_path) == "table" and req_path.path then req_path = req_path.path end
      local bi = orig_get(bim, path, want_cover)
      if type(bi) ~= "table" then return bi end

      local req_leaf = leaf(req_path)
      if base_noext(req_leaf) == wanted_base then
        local _, filename = util.splitFilePathName(req_path or "")
        local basename = filemanagerutil.splitFileNameType(filename)
        if type(basename) == "table" then basename = basename[1] end
        local author, series, title, sidx = parse_filename(basename or "")
        if author and author ~= "" and title and title ~= "" then
          bi.title   = title
          bi.authors = author
          bi.ignore_meta = false
        end
        if series and series ~= "" then
          bi.series = series
          bi.series_index = sidx or 0
          bi.ignore_meta = false
        end
      end
      return bi
    end

    local ok, err = xpcall(function() orig_ListMenuItem_update(self) end, debug.traceback)
    restore()
    if not ok then error(err, 0) end
  end
end

userpatch.registerPatchPluginFunc("coverbrowser", patchCoverBrowser)
